1、ofp_handler是负责底层数据通信的模块。ofp_handler启动之后，start函数实例化了一个controller.OpenFlowController实例。OpenFlowController实例化之后，立即调用__call__()函数，call函数启动了server_loop去创建server socket，其handler为domain_connection_factory函数。每当收到一个switch连接，domain_connection_factory就会实例化一个datapath对象。这个对象用于描述交换机的所有行为。其中定义了接收循环和发送循环。
2、Datapath类中的serve函数是socket通信收发逻辑的入口。该函数启动了一个绿色线程去处理发送循环，然后本线程负责接收循环的处理。self._send_loop是发送主循环。其主要逻辑为：不断获取发送队列是否有数据，若有，则发送；底层调用的是socket.send_all（）函数。
3、接收函数_reck_loop中实现了数据的接收和解析。具体为，首先读出8字节长度的数据（首部），生成msg header，然后根据首部的msg len字段得到剩下的需要读取的字节的长度。当数据读取完后，利用ofproto_parser将数据转换为OpenFlow消息，然后利用ofp_event将OpenFlow消息转变为OpenFlow event，并通过ofp_handler将事件分发出去（send_event_to_observers）。通信过程大致就是这样的，下面详细介绍OpenFlow协议实现的细节，也就是怎么根据收到的数据得到OpenFlow消息。
4、OpenFlow协议解析部分代码大部分在ofproto目录下，少部分在controller目录下。以下内容将首先介绍ofproto目录下的源码内容，再介绍controller目录下的ofp_event文件。
5、/ryu/ryu/ofproto/__init__.py：首先，该文件并不为空，而是定义了两个功能类似的函数get_ofp_module()和get_ofp_modules()，前者用于取得协议版本对应的协议定义文件和协议解析模块，后者则取出整个字典。对应的字典在ofproto_protocol模块中定义。
6、/ryu/ryu/ofproto/ofproto_protocol.py：文件中定义了_versions字典，除此之外，该文件还定义了Datapath的父类ProtocolDesc，此类基本上只完成了与协议版本相关的内容。该类最重要的两个成员是self.ofproto和self.ofproto_parser，其值指明所本次通信所使用的OpenFlow协议的版本以及对应的解析模块。
7、/ryu/ryu/ofproto/ofproto_common.py：主要定义了OpenFlow需要使用的公共属性，如监听端口，报头长度，报头封装格式等内容。
8、/ryu/ryu/ofproto/ofproto_parser.py：定义了OpenFlow消息的基类MsgBase，MsgBase基类定义了最基础的属性信息，此外，该类还定义了基础的parser函数和serialize函数。serialize函数分3部分，self._serialize_pre()，self._serialize_body()和self._serialize_header()，实际上完成了header的序列化。关于body的序列化，将在对应的派生类中得到重写。
9、/ryu/ryu/ofproto/ofproto_v1_x.py：由于Ryu支持多版本的OpenFlow，所以在ofproto目录下，定义了从1.0到1.5版本的所有代码实现，所以其文件命名为ofproto_v1_x.py，x从[1,2,3,4,5]中获得，分别对应相应的协议版本。此类文件最重要的一个目的是定义了所有需要的静态内容，包括某字段的所有选项以及消息封装的格式以及长度，与OpenFlow消息内容相关的所有协议的类型，动作的类型，port的类型等。此外对应每一个报文，都需要定义其封装的格式，以及封装的长度。Ryu采用了Struct库去完成数据的解封装工作。
10、/ryu/ryu/ofproto/ofproto_v1_x_parser.py：本模块用于定义报文的解析等动态内容。模块中定义了与OpenFlow协议对应的Common_struct及message type对应的类。每一个message对应的类都是有MsgBase派生的，其继承了父类的parser函数和serialize函数。若报文无消息体，如Hello报文，则无需重写parser和serialize函数。本模块定义了几个重要的全局函数：_set_msg_type，_register_parser，msg_parser和_set_msg_reply。其作用介绍如下：
_set_msg_type: 完成类与ofproto模块中定义的报文名字的映射，原因在于ofproto模块定义的名字并不是类名，而解析时需要使用ofproto中的名字。
_register_parser：完成对应的类与类中的parser函数的映射，当解析函数从ofproto模块的名字映射到类之后，若需要解析，则需从类对应到对应的解析函数。parser函数是一个类函数，所以在使用时必须传入对应的类的对象作为参数。
_msg_parser：从_MSG_PARSERS中获取对msg_type的parser，并返回解析之后的内容。
_set_msg_reply：完成该类与对应的回应报文的映射。
报文如果有消息体，则需要重写parser函数或者serialize函数，具体根据报文内容而不一样。


